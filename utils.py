# Noitu/utils.py
import discord
from discord.ext import commands
from discord.ui import View 
from . import database
from . import config as bot_cfg 
from . import wiktionary_api 

def get_words_from_input(phrase_input: str) -> list[str]: # D√πng cho VN
    return [word.strip().lower() for word in phrase_input.strip().split() if word.strip()]

def get_last_hiragana_char(hira_string: str) -> str | None:
    if not hira_string:
        return None
    return hira_string[-1]

def get_first_hiragana_char(hira_string: str) -> str | None:
    if not hira_string:
        return None
    return hira_string[0]

async def get_channel_game_settings(bot: commands.Bot, guild_id: int, channel_id: int): # Nh·∫≠n bot instance v√† channel_id
    """L·∫•y c√†i ƒë·∫∑t game c·ªßa guild v√† x√°c ƒë·ªãnh ng√¥n ng·ªØ cho k√™nh c·ª• th·ªÉ."""
    game_lang_for_channel = None
    guild_cfg_data = None

    if bot.db_pool:
        guild_cfg_data = await database.get_guild_config(bot.db_pool, guild_id)
        if guild_cfg_data:
            if guild_cfg_data.get("jp_channel_id") == channel_id:
                game_lang_for_channel = "JP"
            elif guild_cfg_data.get("vn_channel_id") == channel_id:
                game_lang_for_channel = "VN"

    timeout = bot_cfg.DEFAULT_TIMEOUT_SECONDS
    min_players = bot_cfg.DEFAULT_MIN_PLAYERS_FOR_TIMEOUT

    if guild_cfg_data:
        timeout = guild_cfg_data.get("timeout_seconds", bot_cfg.DEFAULT_TIMEOUT_SECONDS)
        min_players = guild_cfg_data.get("min_players_for_timeout", bot_cfg.DEFAULT_MIN_PLAYERS_FOR_TIMEOUT)

    return timeout, min_players, game_lang_for_channel # Tr·∫£ v·ªÅ game_lang_for_channel (c√≥ th·ªÉ l√† None)


async def _send_message_smart(target: discord.Interaction | commands.Context, content=None, embed=None, view=None, ephemeral=False, delete_after=None):
    """G·ª≠i tin nh·∫Øn th√¥ng minh d·ª±a tr√™n context ho·∫∑c interaction."""
    original_message_response = None
    is_interaction_source = False

    if isinstance(target, discord.Interaction):
        is_interaction_source = True
    elif isinstance(target, commands.Context) and hasattr(target, 'interaction') and target.interaction:
        target = target.interaction 
        is_interaction_source = True

    send_kwargs = {} 
    if content is not None: send_kwargs['content'] = content
    if embed is not None: send_kwargs['embed'] = embed
    if view is not None and isinstance(view, View): send_kwargs['view'] = view

    if is_interaction_source:
        if not isinstance(target, discord.Interaction): 
            print(f"L·ªói _send_message_smart: target t∆∞·ªüng l√† interaction nh∆∞ng ko. Type: {type(target)}")
            if hasattr(target, 'channel') and isinstance(target.channel, discord.TextChannel):
                fallback_kwargs = send_kwargs.copy()
                if delete_after is not None and not ephemeral: 
                    fallback_kwargs['delete_after'] = delete_after
                try:
                    return await target.channel.send(**fallback_kwargs)
                except Exception as e_send:
                    print(f"L·ªói fallback send trong _send_message_smart: {e_send}")
            return None # Quan tr·ªçng: tr·∫£ v·ªÅ None n·∫øu c√≥ l·ªói

        interaction_send_kwargs = send_kwargs.copy()
        interaction_send_kwargs['ephemeral'] = ephemeral 

        try:
            if target.response.is_done(): 
                interaction_send_kwargs['wait'] = True 
                original_message_response = await target.followup.send(**interaction_send_kwargs)
            else: 
                await target.response.send_message(**interaction_send_kwargs)
                original_message_response = await target.original_response() 
        except discord.HTTPException as e:
            print(f"L·ªói HTTP khi g·ª≠i/followup tin nh·∫Øn interaction: {e}")
            # Fallback to channel send if possible and not ephemeral
            if hasattr(target, 'channel') and isinstance(target.channel, discord.TextChannel) and not ephemeral:
                try:
                    print("Th·ª±c hi·ªán fallback send to channel.")
                    fallback_kwargs = send_kwargs.copy()
                    if delete_after is not None: fallback_kwargs['delete_after'] = delete_after
                    return await target.channel.send(**fallback_kwargs)
                except Exception as e_fallback:
                    print(f"L·ªói fallback send to channel: {e_fallback}")
            return None


    elif isinstance(target, commands.Context): 
        context_send_kwargs = send_kwargs.copy()
        if delete_after is not None: context_send_kwargs['delete_after'] = delete_after
        try:
            original_message_response = await target.send(**context_send_kwargs)
        except discord.HTTPException as e:
            print(f"L·ªói HTTP khi g·ª≠i tin nh·∫Øn context: {e}")
            return None
    else:
        print(f"L·ªói _send_message_smart: Lo·∫°i target ko xƒë: {type(target)}")
        return None

    return original_message_response 


async def generate_help_embed(bot: commands.Bot, guild: discord.Guild, current_prefix: str, channel_id: int):
    """T·∫°o embed h∆∞·ªõng d·∫´n, nh·∫≠n channel_id ƒë·ªÉ x√°c ƒë·ªãnh ng√¥n ng·ªØ."""
    if not guild: return None, "L·ªói: Kh√¥ng th·ªÉ x√°c ƒë·ªãnh server."

    timeout_s, min_p, game_lang = await get_channel_game_settings(bot, guild.id, channel_id)

    if game_lang is None:
        return None, (
            f"K√™nh n√†y ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh ƒë·ªÉ ch∆°i N·ªëi T·ª´. "
            f"Admin c√≥ th·ªÉ d√πng l·ªánh `/config set_vn_channel` ho·∫∑c `/config set_jp_channel`."
        )

    embed_title = f"üìú Lu·∫≠t ch∆°i N·ªëi T·ª´ ({'Ti·∫øng Vi·ªát' if game_lang == 'VN' else 'Ti·∫øng Nh·∫≠t - „Åó„Çä„Å®„Çä'})"
    embed = discord.Embed(title=embed_title, color=discord.Color.teal())
    
    common_rules = (
        f"S·ª≠ d·ª•ng l·ªánh slash (g√µ `/` ƒë·ªÉ xem) ho·∫∑c l·ªánh prefix (hi·ªán t·∫°i l√† `{current_prefix}`).\n"
        f"Sau khi c√≥ √≠t nh·∫•t **{min_p}** ng∆∞·ªùi ch∆°i kh√°c nhau tham gia, n·∫øu sau **{timeout_s} gi√¢y** kh√¥ng ai n·ªëi ƒë∆∞·ª£c t·ª´ c·ªßa b·∫°n, b·∫°n **th·∫Øng**!"
    )

    if game_lang == "VN":
        embed.description = (
            f"{common_rules}\n"
            f"**Lu·∫≠t ch∆°i (Ti·∫øng Vi·ªát):** ƒê∆∞a ra c·ª•m t·ª´ **ƒë√∫ng 2 ch·ªØ** ti·∫øng Vi·ªát, c√≥ nghƒ©a v√† ƒë∆∞·ª£c Wiktionary c√¥ng nh·∫≠n. "
            f"Ch·ªØ ƒë·∫ßu c·ªßa c·ª•m m·ªõi ph·∫£i l√† ch·ªØ th·ª© hai c·ªßa c·ª•m tr∆∞·ªõc."
        )
        start_game_help = f"`/start [ch·ªØ1 ch·ªØ2]` ho·∫∑c `{current_prefix}start [ch·ªØ1 ch·ªØ2]`.\nN·∫øu kh√¥ng nh·∫≠p t·ª´, bot t·ª± ch·ªçn."
    else: # JP
        embed.description = (
            f"{common_rules}\n"
            f"**Lu·∫≠t ch∆°i (Ti·∫øng Nh·∫≠t - Shiritori):** ƒê∆∞a ra m·ªôt t·ª´ ti·∫øng Nh·∫≠t (Kanji, Hiragana, Katakana, Romaji). "
            f"T·ª´ ph·∫£i c√≥ nghƒ©a v√† ƒë∆∞·ª£c t·ª´ ƒëi·ªÉn/Wiktionary c√¥ng nh·∫≠n.\n"
            f"√Çm ti·∫øt (Hiragana) cu·ªëi c·ªßa t·ª´ tr∆∞·ªõc ph·∫£i l√† √¢m ti·∫øt ƒë·∫ßu c·ªßa t·ª´ sau.\n"
            f"**QUAN TR·ªåNG:** T·ª´ k·∫øt th√∫c b·∫±ng √¢m '„Çì' (n) s·∫Ω khi·∫øn ng∆∞·ªùi ch∆°i ƒë√≥ **THUA CU·ªòC** ngay l·∫≠p t·ª©c!"
        )
        start_game_help = f"`/start [t·ª´ ti·∫øng Nh·∫≠t]` ho·∫∑c `{current_prefix}start [t·ª´ ti·∫øng Nh·∫≠t]`.\nN·∫øu kh√¥ng nh·∫≠p t·ª´, bot t·ª± ch·ªçn."

    embed.add_field(name="üéÆ B·∫Øt ƒë·∫ßu game", value=f"{start_game_help}\nN√∫t 'B·∫Øt ƒê·∫ßu Nhanh' (bot ch·ªçn t·ª´).", inline=False)
    embed.add_field(name="üõë D·ª´ng game", value=f"`/stop` ho·∫∑c `{current_prefix}stop`.", inline=False)
    embed.add_field(name="üèÜ B·∫£ng x·∫øp h·∫°ng", value=f"`/bxh` ho·∫∑c `{current_prefix}bxh` (hi·ªÉn th·ªã BXH cho ng√¥n ng·ªØ c·ªßa k√™nh n√†y).", inline=False)
    embed.add_field(name="‚öôÔ∏è C·∫•u h√¨nh (Admin)",
                    value=(f"`/config view` - Xem c·∫•u h√¨nh k√™nh.\n"
                           f"`/config set_prefix <k√≠_t·ª±>`\n"
                           f"`/config set_timeout <gi√¢y>`\n"
                           f"`/config set_minplayers <s·ªë>`\n"
                           f"`/config set_vn_channel <#k√™nh>` - ƒê·∫∑t k√™nh ch∆°i Ti·∫øng Vi·ªát.\n"
                           f"`/config set_jp_channel <#k√™nh>` - ƒê·∫∑t k√™nh ch∆°i Ti·∫øng Nh·∫≠t.\n"
                           f"Ho·∫∑c `{current_prefix}config ...` (l·ªánh prefix c√≥ th·ªÉ kh√¥ng h·ªó tr·ª£ h·∫øt c√°c c·∫•u h√¨nh k√™nh)."),
                    inline=False)
    embed.set_footer(text=f"Bot th·∫£ reaction: ‚úÖ ƒë√∫ng, ‚ùå sai t·ª´/ƒë√£ d√πng, ‚ö†Ô∏è sai l∆∞·ª£t, {bot_cfg.SHIRITORI_LOSS_REACTION} thua (lu·∫≠t '„Çì').")
    return embed, None


async def generate_leaderboard_embed(bot: commands.Bot, guild: discord.Guild, game_language: str):
    """T·∫°o embed b·∫£ng x·∫øp h·∫°ng. Tr·∫£ v·ªÅ (embed, error_message_str)."""
    if not bot.db_pool:
        return None, "L·ªói: DB ch∆∞a s·∫µn s√†ng."
    if not guild:
        return None, "L·ªói: Kh√¥ng th·ªÉ x√°c ƒë·ªãnh server."
    if game_language not in ["VN", "JP"]:
        return None, "L·ªói: Ng√¥n ng·ªØ kh√¥ng h·ª£p l·ªá cho b·∫£ng x·∫øp h·∫°ng."

    game_lang_name = "Ti·∫øng Vi·ªát" if game_language == "VN" else "Ti·∫øng Nh·∫≠t („Åó„Çä„Å®„Çä)"
    async with bot.db_pool.acquire() as conn:
        # Th√™m c·ªôt lost_by_n_ending v√†o SELECT n·∫øu c·∫ßn hi·ªÉn th·ªã
        rows = await conn.fetch(
            """
            SELECT name, wins, correct_moves, wrong_word_link, invalid_wiktionary, used_word_error, wrong_turn, 
                   lost_by_n_ending, current_win_streak, max_win_streak
            FROM leaderboard_stats 
            WHERE guild_id = $1 AND game_language = $2
            ORDER BY wins DESC, correct_moves DESC, max_win_streak DESC, current_win_streak DESC,
                     (wrong_word_link + invalid_wiktionary + used_word_error + wrong_turn + lost_by_n_ending) ASC, 
                     name ASC
            LIMIT 10;
            """, guild.id, game_language
        )

    guild_name_escaped = discord.utils.escape_markdown(guild.name)
    if not rows:
        return None, f"Ch∆∞a c√≥ ai tr√™n BXH N·ªëi T·ª´ ({game_lang_name}) c·ªßa server **{guild_name_escaped}**!"

    embed = discord.Embed(title=f"üèÜ BXH N·ªëi T·ª´ ({game_lang_name}) - {guild_name_escaped} üèÜ", color=discord.Color.gold())
    desc = ""
    emojis = ["ü•á", "ü•à", "ü•â"] 
    for i, s_dict in enumerate(rows):
        s = dict(s_dict) 
        rank_display = emojis[i] if i < len(emojis) else f"**{i+1}.**"
        streak_info = f" (Hi·ªán t·∫°i: {s['current_win_streak']})" if s['current_win_streak'] > 0 else ""
        
        total_errors = s.get("wrong_word_link",0) + s.get("invalid_wiktionary",0) + s.get("used_word_error",0)
        if game_language == "JP":
            total_errors += s.get("lost_by_n_ending", 0)
        
        player_name = s['name']
        if len(player_name) > 25: player_name = player_name[:22] + "..." 

        desc += (f"{rank_display} **{discord.utils.escape_markdown(player_name)}**\n"
                 f"   üèÖ Th·∫Øng: `{s['wins']}` | ‚úÖ L∆∞·ª£t ƒë√∫ng: `{s['correct_moves']}`\n"
                 f"   üî• Chu·ªói max: `{s['max_win_streak']}`{streak_info}\n"
                 f"   ‚ö†Ô∏è L·ªói (g·ªôp): `{total_errors}` | ‚è∞ Sai l∆∞·ª£t: `{s['wrong_turn']}`\n\n") # 'L·ªói (g·ªôp)'

    embed.description = desc.strip()
    embed.set_footer(text=f"BXH ({game_lang_name}): Th·∫Øng > L∆∞·ª£t ƒë√∫ng > Chu·ªói max > Chu·ªói hi·ªán t·∫°i > √çt l·ªói > T√™n.")
    return embed, None